;license:MIT
;(c) 2018-9 by 4am
;
; first-run initialization code
;
; This file is included directly and is run from $2000/main as soon as the
; .SYSTEM file is loaded
;

         +READ_ROM_NO_WRITE
         sta   PRIMARYCHARSET
         sta   CLR80VID
         sta   STOREOFF
         sta   READMAINMEM
         sta   WRITEMAINMEM
         jsr   ROM_TEXT
         jsr   ROM_HOME
         jsr   Has64K                ; check for 64K (required)
         bcs   @no64K
         jsr   DisableAccelerator    ; set to 1 MHz (supports IIgs and many common accelerator cards)
         jsr   IsGS                  ; check for IIgs (allows super hi-res artwork)
         ror   zpMachineStatus
         jsr   HasVidHDCard          ; check for VidHD card (allows super hi-res artwork even on non-IIgs machines)
         ror   zpMachineStatus
         jsr   Has128K               ; check for 128K (allows DHGR slideshows and 128K games)
         ror   zpMachineStatus
         jsr   HasJoystick           ; check for joystick (absence is OK but we filter out some games that require a joystick)
         ror   zpMachineStatus       ; now bit 4 = 1 if IIgs
                                     ;     bit 5 = 1 if VidHD
                                     ;     bit 6 = 1 if 128K
                                     ;     bit 7 = 1 if joystick

         +READ_ROM_WRITE_RAM2
         jsr   init                  ; initialize and relocate ProRWTS2 to $D400 in RAM bank 2
                                     ; ProRWTS2 disk-data live at $D000-D3FF
         ldx   #$00                  ; relocate program code to top of language card
                                     ; since we end at $0000 now, adjust low offset to avoid destroying zpage
@FM      lda   FirstMover - (RELBASE & $FF),x
         sta   RELBASE & $FF00,x
         inx
         bne   @FM
         inc   @FM+2
         inc   @FM+5
         bne   @FM

+        ldy   #$04
@LM      lda   LastMover,x           ; relocate font data to $D600 in RAM bank 2
         sta   $D600,x
         inx
         bne   @LM
         inc   @LM+2
         inc   @LM+5
         dey
         bne   @LM

         jmp   OneTimeSetup

@no64K
         ldy   #@no64Klen
-        lda   @s_no64K,y
         sta   $6B6,y
         dey
         bpl   -
@hang    bmi   @hang
@s_no64K !raw  "REQUIRES 64K"
@no64Klen=*-@s_no64K

         ; ProRWTS2 has its own function to relocate itself
         !source "src/prorwts2.a"
ProRWTSBuffer
         ; these routines will only be called once, from main memory, before relocating to language card
         !source "src/hw.iigs.a"
         !source "src/hw.vidhd.a"
         !source "src/hw.memcheck.a"
         !source "src/hw.joystick.a"
         !source "src/hw.normfast.a"
*=ProRWTSBuffer+512                  ; ProRWTS needs a 512-byte buffer for its init function
                                     ; so we reuse as much of the 1-time code as possible
                                     ; and fill the rest with zeros

         !source "src/parse.games.a" ; this needs to be outside the buffer because it's not used
                                     ; until after ProRWTS initialization

OneTimeSetup
         lda   zpMachineStatus
         sta   MachineStatus         ; save machine status
         jsr   SaveOrRestoreScreenHoles ; save initial copy of screen hole content
         lda   #$91
         sta   holepatch             ; enable restoring of copy from now on
         lda   hddopendir+1          ; save current directory as 'root'
         ldy   hddopendir+3
         +READ_RAM1_WRITE_RAM1
         +STAY gRootDirectory

         lda   $43
         sta   promote + ProDOS_unit - $bf00
                                     ; save unit while overriding !pseudopc

         +LDADDR kGlobalPrefsFilename
         jsr   SetPath
         jsr   LoadFile              ; load preferences file into $8000

         jsr   ParseKeyValueList     ; parse contents into OKVS data structure into LC RAM bank
         !word gGlobalPrefsStore
         !word ldrlo2                ; (ldrlo2) points to last load address, so $8000
         !byte 16
         +LDAY SRC                   ; (SRC) points to free space after the OKVS data structure we just created
         +STAY gGamesListStore       ; save pointer to free space for next store

         +LDADDR @kGameListConfFile
         jsr   SetPath
         jsr   LoadFile              ; load games list file into $8000

         jsr   ParseGamesList        ; parse games list into OKVS data structure in LC RAM bank
         !word gGamesListStore
         !word ldrlo2                ; (ldrlo2) points to last load address, so $8000

         jsr   okvs_len
         !word gGamesListStore
         sta   GameCount
         sta   SAVE
         ; calculate and update visible game count (3-digit decimal number as ASCII string)
         ldy   #0
@outer
         lda   #0
         pha
@inner
         lda   SAVE
         cmp   @kPowersOfTen,y
         bcc   @digitDone
         sbc   @kPowersOfTen,y
         sta   SAVE
         lda   SAVE+1
         sbc   #0
         sta   SAVE+1
         pla
         adc   #0
         pha
         jmp   @inner
@digitDone
         pla
         ora   #$30
         sta   VisibleGameCount,y
         iny
         cpy   #$03
         bcc   @outer

         ldx   #5
-        lda   Prelaunch,x           ; copy reentry wrapper to bottom of stack
         sta   $100,x                ; (used as reset vector because ][+ always
         dex                         ; switches to ROM on Ctrl-Reset)
         bpl   -

         inx
         stx   $3F2                  ; page 3 reset vector to ($100)
         inx
         stx   $3F3
         ldx   #$A4
         stx   $3F4

         bit   CLEARKBD

         jmp   $100                  ; will jump to |Reentry| in LC RAM bank

@kGameListConfFile
         !byte 10
         !text "GAMES.CONF"

@kPowersOfTen
         !byte 100
         !byte 10
         !byte 1
